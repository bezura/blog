---
title: Управление версиями. Git.

# Summary for listings and search engines
summary: Управление версиями. Git.

# Link this post with a project
projects: []

# Date published
date: '2023-03-18T00:00:02Z'

# Date updated
lastmod: '2023-03-18T00:00:02Z'

# Is this an unpublished draft?
draft: false

# Show this page in the Featured widget?
featured: false

# Featured image
# Place an image named `featured.jpg/jpg` in this page's folder and customize its options here.
image:
  caption: 'Image credit: [**Unsplash**]()'
  focal_point: ''
  placement: 2
  preview_only: false

authors:
  - admin

tags:
  - Academic

categories:
  - Demo
---

```python
import libr
print('hello')
```


# **Системы контроля версий.Общие понятия**

**Системы контроля версий (Version Control System,VCS)** применяются при работе нескольких человек над одним проектом.Обычно основное дерево про- екта хранится в локальном или удалённом репозитории,к которому настроен доступдля участников проекта.При внесении изменений в содержание проекта система контроля версий позволяет их фиксировать, совмещать изменения, произведённые разными участниками проекта, производить откат к любой более ранней версии проекта,если это требуется.

В классических системах контроля версий используется централизованная модель,предполагающая наличие единого репозитория для хранения файлов. Выполнение большинства функций по управлению версиями осуществляется специальнымсервером.Участникпроекта(пользователь)передначаломработы посредствомопределённыхкомандполучаетнужнуюемуверсиюфайлов.После внесения изменений,пользователь размещает новую версию в хранилище.При этом предыдущие версии не удаляются из центрального хранилища и к ним можно вернуться в любой момент.Сервер может сохранять не полную версию изменённых файлов,а производитьтак называемую дельта-компрессию—со- хранятьтолько изменения между последовательными версиями,что позволяет уменьшить объём хранимых данных.

Системы контроля версий поддерживаютвозможностьотслеживания и разре- шения конфликтов,которые могут возникнуть при работе нескольких человек над одним файлом.Можно объединить (слить) изменения,сделанные разными участниками (автоматически или вручную),вручную выбрать нужную версию, отменить изменения вовсе или заблокировать файлы для изменения.В зависи- мости от настроек блокировка не позволяетдругим пользователям получить рабочую копию или препятствует изменению рабочей копии файла средствами файловой системы ОС,обеспечиваятаким образом,привилегированныйдоступ только одному пользователю,работающему с файлом.

Системы контроля версий также могут обеспечивать дополнительные,более гибкие функциональные возможности. Например, они могут поддерживать работу с несколькими версиями одного файла,сохраняя общую историю изме- нений до точки ветвления версий и собственные истории изменений каждой ветви.Кроме того,обычно доступна информация о том,кто из участников,ко- гда и какие изменения вносил. Обычно такого рода информация хранится в журнале изменений,доступ к которому можно ограничить.

В отличие от классических,в распределённых системах контроля версий цен- тральный репозиторий не является обязательным.

Среди классических VCS наиболее известны CVS,Subversion,а среди распре- делённых—Git,Bazaar,Mercurial.Принципы их работы схожи,отличаются они в основном синтаксисом используемых в работе команд.

# **Система контроля версий Git**

**Система контроля версий Git** представляет собой набор программ команд- ной строки. Доступ к ним можно получить из терминала посредством ввода команды git с различными опциями.

Благодаря тому,что Git является распределённой системой контроля версий, резервную копию локального хранилища можно сделать простым копировани- ем или архивацией.

# **Основные команды git**

Наиболее часто используемые команды git представлены в таблице нижу 

Команда Описание![](Aspose.Words.d8d007bc-3873-4168-a695-b631a7f23e98.003.jpg)

git init создание основного дерева репозитория

git pull получение обновлений (изменений) текущего дерева из

центрального репозитория

git push отправка всех произведённых изменений локального

дерева в центральный репозиторий

git status просмотр списка изменённых файлов в текущей

директории

git diff просмотр текущих изменения

git add . добавить все изменённые и/или созданные файлы и/или

каталоги

git add добавить конкретные изменённые и/или созданные файлы имена\_файлов и/или каталоги

git rm удалить файл и/или каталог из индекса репозитория (при имена\_файлов этом файл и/или каталог остаётся в локальной директории)

git commit сохранить все добавленные изменения и все изменённые -am 'Описание файлы коммита'

Команда Описание![](Aspose.Words.d8d007bc-3873-4168-a695-b631a7f23e98.006.jpg)

git checkout создание новой ветки,базирующейся на текущей -b имя\_ветки

git checkout переключение на некоторую ветку (при переключении на имя\_ветки ветку,которой ещё нет в локальном репозитории,она будет

создана и связана с удалённой)

git push отправка изменений конкретной ветки в центральный origin репозиторий

имя\_ветки

git merge слияние ветки с текущим деревом --no-ff

имя\_ветки

git branch -d удаление локальной уже слитой с основным деревом ветки имя\_ветки

git branch -D принудительное удаление локальной ветки

имя\_ветки

git push удаление ветки с центрального репозитория

origin

:имя\_ветки![](Aspose.Words.d8d007bc-3873-4168-a695-b631a7f23e98.005.jpg)

# **Стандартные процедуры работы при наличии центрального репозитория**

Работа пользователя со своей веткой начинается с проверки и получения изменений из центрального репозитория (при этом в локальное дерево до начала этой процедуры не должно было вноситься изменений):![](Aspose.Words.d8d007bc-3873-4168-a695-b631a7f23e98.004.jpg)


git checkout master

git pull

git checkout -b имя\_ветки

Затем можно вносить изменения в локальном дереве и/или ветке.

После завершения внесения какого-то изменения в файлы и/или каталоги проекта необходимо разместить их в центральном репозитории. Для этого необходимо проверить,какие файлы изменились к текущему моменту:

git status

и при необходимости удаляем лишние файлы,которые не хотим отправлять в центральный репозиторий.

Затем полезно просмотретьтекст изменений на предмет соответствия прави- лам ведения чистых коммитов:

git diff

Если какие-либо файлы не должны попасть в коммит,то помечаем только те файлы,изменения которых нужно сохранить.Для этого используем команды добавления и/или удаления с нужными опциями:

git add имена\_файлов git rm имена\_файлов

Если нужно сохранить все изменения в текущем каталоге,то используем: git add .

Затем сохраняем изменения,поясняя,что было сделано:

git commit -am "Some commit message"

и отправляем в центральный репозиторий:

git push origin имя\_ветки

или

git push

